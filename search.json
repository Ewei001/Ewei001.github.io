[{"title":"Multiple Thread","url":"http://yoursite.com/2017/05/03/MultipleThread/","content":"<h2 id=\"Java中的多线程\"><a href=\"#Java中的多线程\" class=\"headerlink\" title=\"Java中的多线程\"></a>Java中的多线程</h2><p>用并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。</p>\n<h3 id=\"创建线程的三种方法\"><a href=\"#创建线程的三种方法\" class=\"headerlink\" title=\"创建线程的三种方法\"></a>创建线程的三种方法</h3><ul>\n<li>通过Runnable接口创建线程类</li>\n<li>继承Thread类创建线程类</li>\n<li>通过Callable和Future创建线程<br>这三种基本方法的具体例子就不详细地讲了，简单介绍一下。</li>\n</ul>\n<h4 id=\"通过实现Runnable接口创建线程类\"><a href=\"#通过实现Runnable接口创建线程类\" class=\"headerlink\" title=\"通过实现Runnable接口创建线程类\"></a>通过实现Runnable接口创建线程类</h4><p>要想定义任务，只需实现Runnable接口并编写run()方法，使得该任务可以执行你的命令。<br>当从Runnable导出一个类时，它必须具有run()方法，但是这个方法并无特殊之处——它不会产生任何内在的线程能力。要实现线程行为，必须显示地将一个任务附着到线程上。<br>不返回任何值。</p>\n<h4 id=\"继承Thread类创建线程类\"><a href=\"#继承Thread类创建线程类\" class=\"headerlink\" title=\"继承Thread类创建线程类\"></a>继承Thread类创建线程类</h4><p>将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器。<br>调用Thread对象的start()方法为该线程执行必需的初始化操作。</p>\n<h4 id=\"通过Callable和FutureTask创建线程\"><a href=\"#通过Callable和FutureTask创建线程\" class=\"headerlink\" title=\"通过Callable和FutureTask创建线程\"></a>通过Callable和FutureTask创建线程</h4><ol>\n<li>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。</li>\n<li>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了对象的call()方法的返回值。</li>\n<li>使用FutureTask对象作为Thread对象的target创建并启动新线程。</li>\n<li>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值<br>任务完成时能够返回一个值。</li>\n</ol>\n<h3 id=\"关于线程池\"><a href=\"#关于线程池\" class=\"headerlink\" title=\"关于线程池\"></a>关于线程池</h3><h4 id=\"使用线程池的原因\"><a href=\"#使用线程池的原因\" class=\"headerlink\" title=\"使用线程池的原因\"></a>使用线程池的原因</h4><ol>\n<li>减少在创建和销毁线程上所花的时间以及系统资源的开销</li>\n<li>如果不使用线程池，有可能造成系统创建大量线程而导致消耗完系统内存以及“过渡切换”</li>\n</ol>\n<h3 id=\"concurrent包下面的一些类\"><a href=\"#concurrent包下面的一些类\" class=\"headerlink\" title=\"concurrent包下面的一些类\"></a>concurrent包下面的一些类</h3><p>Java.util.concurrent引入了大量设计用来解决并发问题的新类。学习使用它们将有助于你编写出更加简洁而健壮的并发程序。</p>\n<h4 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h4><p>它被用来同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。<br>你可以向CountDownLatch对象设置一个初始计数值，任何在这个对象上调用wait()方法都将阻塞，直到这个计数值达到0.<br>其他任务在结束其工作时，可以在该对象上调用countDown()来减小这个计数值。CountLatch被设计为只触发一次，计数值不能被重置。<br>如果需要能够重置计数值的版本，可以使用CyclicBarrier.<br>CountDownLatch的典型用法是将一个程序分为n个相互独立的可解决任务，并创建值为0的CountDownLatch。当每个任务完成时，都会在这个锁存器上调用countDown()。<br>等待问题被解决的任务在这个锁存器上调用await()，将它们自己拦住，直至锁存器计数结束。</p>\n<h4 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h4><p>你希望创建一组任务，它们并行地执行工作，然后在进行下一个步骤之前等待，直至所有任务都完成（有些像join）<br>它使得所有并行任务都在栅栏处队列，因此可以一致地向前移动。<br>与CountDownLatch的区别是CyclicBarrier可以多次重用。而CountDownLatch只触发一次事件。</p>\n<h4 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h4><p>这是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。<br>这种队列是有序的，即队头对象的延迟到期的时间最长。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将返回null</p>\n<h4 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h4><h3 id=\"Java内存模型与多线程\"><a href=\"#Java内存模型与多线程\" class=\"headerlink\" title=\"Java内存模型与多线程\"></a>Java内存模型与多线程</h3><h3 id=\"关于volatile关键字\"><a href=\"#关于volatile关键字\" class=\"headerlink\" title=\"关于volatile关键字\"></a>关于volatile关键字</h3>","categories":["Java"],"tags":["Java"]},{"title":"关于pip安装依赖包问题","url":"http://yoursite.com/2017/05/03/关于pip安装依赖包问题/","content":"<p>公司最近在开发一个Python项目，<br>当我在配置开发环境，使用pip安装依赖包时，出现了以下问题：<br><img src=\"/images/problem.jpg\" alt=\"problem\"></p>\n<p>试了很多遍，一直以为是网络的问题，因为Python之前有安装过，也可以使用<br>在命令行试了一下Python，可以识别<br>但是pip却识别不了<br>原因：计算机可能不知道pip装在哪里<br>因为之前我的Python默认安装路径很多都是隐藏的，找起来很麻烦<br>干脆就卸载了重新装了一下<br>然后再配一下两个环境变量：<br>F:\\program files\\python<br>F:\\program files\\python\\Scripts<br>注意：scripts下是pip的路径，这个我是在安装Python时一起安装的，如果之前没有装，就需要先装一下再配环境。<br>然后再命令行试pip<br><img src=\"/images/solved.jpg\" alt=\"solved\"><br>应该就是成功了，下面就可以安装自己需要的依赖包了~</p>\n","categories":["python"],"tags":["python"]},{"title":"Java Reflection","url":"http://yoursite.com/2017/05/02/Java-Reflection/","content":"","categories":["Java"],"tags":["Java"]},{"title":"about SpringFramework","url":"http://yoursite.com/2017/04/30/about SpringFramework/","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>因为简历的项目里有写到spring，所以面试都会被问到spring的问题，由于是几年前的项目，也没有相关准备，所以被问到的时候有些懵逼……</p>\n<h1 id=\"主要三个问题\"><a href=\"#主要三个问题\" class=\"headerlink\" title=\"主要三个问题\"></a>主要三个问题</h1><ul>\n<li>spring是什么，为什么要用spring</li>\n<li>spring中的IOC和AOP，是为了解决什么样的问题</li>\n<li>springMVC工作原理</li>\n</ul>\n<h2 id=\"spring是什么，为什么要用spring\"><a href=\"#spring是什么，为什么要用spring\" class=\"headerlink\" title=\"spring是什么，为什么要用spring\"></a>spring是什么，为什么要用spring</h2><p>spring是J2EE的开源框架，提供了对轻量级IOC的良好支持，同时也提供了对AOP技术非常好的封装。相比其它框架，Spring框架的设计更加模块化，框架内的每个模块都能完成特定的工作，而且各个模块可以独立运行，不会相互牵制。<br>因此在使用spring框架时，开发人员可以使用整个框架，也可以只使用框架内的一部分模块，例如可以只使用spring AOP模块来实现日志管理功能，而不需要使用其他模块。<br>Spring帮助开发者解决了开发中的基础性问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心地继承Spring框架，不必担心SPring是如何在后台进行工作的。</p>\n<h3 id=\"SPring有七大功能模块，分别是：\"><a href=\"#SPring有七大功能模块，分别是：\" class=\"headerlink\" title=\"SPring有七大功能模块，分别是：\"></a>SPring有七大功能模块，分别是：</h3><ul>\n<li><strong>CORE</strong> Core模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Spring的所有功能都是借助IOC实现的。</li>\n<li><strong>AOP</strong> AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常用的拦截器，供用户自定义和配置。同时这个模块也提供了事务管理，可以不依赖于具体的EJB组件，就可以将事务管理集成到应用程序中。</li>\n<li><strong>ORM</strong> Spring的ORM模块提供对常用的ORM框架的管理和辅助支持，Spring支持常用的Hibernate,mybatis等框架的支持，Spring本身并不对ORM进行实现，仅对常见的ORM框架进行封装，并对其进行管理。</li>\n<li><strong>DAO</strong> Spring提供对数据访问对象模式和对JDBC的支持。DAO可以实现把业务逻辑与数据库访问的代码实现分离，从而降低代码的耦合度。通过JDBC的抽象，简化了开发工作，同时简化了对异常的处理（可以很好地处理不同数据库厂商抛出的异常）</li>\n<li><strong>WEB</strong> WEB模块提供对常见框架如Struts1,webwork（struts2）,JSF的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器。</li>\n<li><strong>CONTEXT</strong> CONTEXT模块提供框架式的Bean访问方式，其他程序可以通过Context访问Spring的Bean资源，相当于资源注入。扩展核心容器，提供了spring上下文环境，给开发人员提供了很多非常有用的服务。</li>\n<li><strong>MVC</strong> WEB MVC模块为Spring提供了一套轻量级的MVC实现，在Spring的开发中，我们既可以用Struts也可以用Spring自己的MVC框架，相对于Struts，Spring自己的MVC框架更加简洁方便。</li>\n</ul>\n<h3 id=\"spring有哪些优点\"><a href=\"#spring有哪些优点\" class=\"headerlink\" title=\"spring有哪些优点\"></a>spring有哪些优点</h3><ul>\n<li>在使用J2EE开发多层应用程序时，Spring有效地管理了中间层代码，由于spring采用了控制反转和面向切面编程的思想，因此这些代码非常容易测试。</li>\n<li>使用spring有助于开发人员培养一个良好的编程习惯：面向接口编程而不是面向类编程。面向接口编程使得程序有更好的可扩展性。</li>\n<li>spring对数据的存取提供了一个一致的框架</li>\n<li>spring通过支持不同的事务处理API的方法对事务的管理提供了一致的抽象方法。</li>\n<li>使用spring框架编写的大部分业务对象不需要依赖spring</li>\n</ul>\n<h2 id=\"spring中的IOC和AOP，是为了解决什么样的问题\"><a href=\"#spring中的IOC和AOP，是为了解决什么样的问题\" class=\"headerlink\" title=\"spring中的IOC和AOP，是为了解决什么样的问题\"></a>spring中的IOC和AOP，是为了解决什么样的问题</h2><h3 id=\"什么是IOC\"><a href=\"#什么是IOC\" class=\"headerlink\" title=\"什么是IOC\"></a>什么是IOC</h3><p>控制反转(Inverse of Control, IOC)有时也被称为依赖注入DI(Dependency Injection)，是一种降低对象之间耦合关系的设计思想。<br>一般而言，在分层体系结构中，都是上层调用下层的接口，上层依赖于下层的执行，即调用者依赖于被调用者。<br>而通过IOC方式，使得上层不再依赖于下层的接口，即通过采用一定的机制来选择不同的下层实现，完成控制反转，使得由调用者来决定被调用者。<br>IOC通过注入一个实例化的对象来达到解耦的目的。使用这种方法后，对象不会被显示地调用，而是根据需求通过IOC容器（例如spring）来提供。<br>创建被调用者的工作由spring来完成，然后注入调用者，因此也称为依赖注入。</p>\n<h4 id=\"依赖注入spring的方式：\"><a href=\"#依赖注入spring的方式：\" class=\"headerlink\" title=\"依赖注入spring的方式：\"></a>依赖注入spring的方式：</h4><ul>\n<li>set注入方式</li>\n<li>构造方法注入方式</li>\n<li>基于注解的方式</li>\n</ul>\n<h4 id=\"IOC主要有以下两个方面的优点：\"><a href=\"#IOC主要有以下两个方面的优点：\" class=\"headerlink\" title=\"IOC主要有以下两个方面的优点：\"></a>IOC主要有以下两个方面的优点：</h4><ul>\n<li>通过IOC容器，开发人员不需要关注对象如何被创建，同时增加新类也非常方便，只需要修改配置文件即可实现对象的“热插拔”。</li>\n<li>IOC容器可以通过配置文件来确定需要注入的实例化对象，因此非常便于进行单元测试。</li>\n</ul>\n<h4 id=\"IOC的缺点：\"><a href=\"#IOC的缺点：\" class=\"headerlink\" title=\"IOC的缺点：\"></a>IOC的缺点：</h4><ul>\n<li>对象是通过反射机制实例化出来的，因此会对性能有一定的影响。如果不了解Java中的反射机制可以看另一篇<a href=\"https://ewei001.github.io/2017/05/02/Java-Reflection/\" target=\"_blank\" rel=\"external\">Java Reflection</a></li>\n<li>创建对象的流程变得比较复杂</li>\n</ul>\n<h3 id=\"什么是AOP\"><a href=\"#什么是AOP\" class=\"headerlink\" title=\"什么是AOP\"></a>什么是AOP</h3><p>面向切面编程(Aspect-Oriented Programming, AOP)是对面向对象开发的一种补充，它允许开发人员在不改变原来模型的基础上动态地修改模型以满足新的需求。<br>例如，开发人员可以在不改变原来业务逻辑模型的基础上可以动态地增加日志、安全或异常处理的功能。<br>AOP从程序运行角度考虑程序的结构，提取业务处理过程的切面，oop是静态的抽象，aop是动态的抽象。</p>\n<h4 id=\"面向切面编程在spring中主要表现为两个方面\"><a href=\"#面向切面编程在spring中主要表现为两个方面\" class=\"headerlink\" title=\"面向切面编程在spring中主要表现为两个方面\"></a>面向切面编程在spring中主要表现为两个方面</h4><ul>\n<li>面向切面编程提供声明式事务管理</li>\n<li>spring支持用户自定义的切面<h4 id=\"AOP两个特征\"><a href=\"#AOP两个特征\" class=\"headerlink\" title=\"AOP两个特征\"></a>AOP两个特征</h4></li>\n<li>各个步骤之间良好的隔离性</li>\n<li>源码无关性<br><a href=\"http://blog.csdn.net/kiss_vicente/article/details/6901295\" target=\"_blank\" rel=\"external\">AOP的例子</a></li>\n</ul>\n<h2 id=\"springMVC的工作原理\"><a href=\"#springMVC的工作原理\" class=\"headerlink\" title=\"springMVC的工作原理\"></a>springMVC的工作原理</h2><p>Spring的MVC框架主要由DispatcherServlet、处理器映射、处理器（控制器）、视图解析器、视图组成。<br><img src=\"/images/SpringMVC.jpg\" alt=\"SpringMVC\"></p>\n<h3 id=\"SpringMVC接口解释\"><a href=\"#SpringMVC接口解释\" class=\"headerlink\" title=\"SpringMVC接口解释\"></a>SpringMVC接口解释</h3><p><strong>DispatcherServlet接口</strong> Spring提供的前端控制器，所有的请求都有经过它来统一分发。DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller.<br><strong>HandlerMapping接口</strong> 能够完成客户请求到Controller映射。<br><strong>Controller接口</strong> 需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）.<br>从宏观角度考虑，DispatcherServlet是整个web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）.<br><strong>ViewResolver接口</strong> Spring提供的视图解析器（ViewResolver）在web应用中查找view对象，从而将相应结果渲染给客户。</p>\n<h3 id=\"SpringMVC运行原理\"><a href=\"#SpringMVC运行原理\" class=\"headerlink\" title=\"SpringMVC运行原理\"></a>SpringMVC运行原理</h3><ul>\n<li>客户端请求提交到DispatcherServlet</li>\n<li>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller</li>\n<li>DispatcherServlet将请求提交到Controller</li>\n<li>Controller调用业务逻辑处理后，返回ModelAndView</li>\n<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图</li>\n<li>视图负责将结果显示到客户端</li>\n</ul>\n<h4 id=\"DispatcherServlet是整个Spring-MVC的核心。它负责接收HTTP请求组织协调Spring-MVC的各个组成部分。主要工作由以下三项：\"><a href=\"#DispatcherServlet是整个Spring-MVC的核心。它负责接收HTTP请求组织协调Spring-MVC的各个组成部分。主要工作由以下三项：\" class=\"headerlink\" title=\"DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。主要工作由以下三项：\"></a>DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分。主要工作由以下三项：</h4><ul>\n<li>截获符合特定格式的URL请求。</li>\n<li>初始化DispatcherServlet上下文对应的WebApplicationContext，并将其与业务层、持久化层的WebApplication建立关联。</li>\n<li>初始化Spring MVC的各个组成组件，并装配到DispatcherServlet中。</li>\n</ul>\n","categories":["Java"],"tags":["J2EE"]},{"title":"blog note","url":"http://yoursite.com/2017/04/26/blog note/","content":"<h2 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h2><p>最近想了很多，本科四年都没有出去实习，每次提到面试都很畏惧<br>现在遇到了很多很优秀的人，感觉和别人的差距真是太大了<br>最近面试了很多公司，因为实习的原因也没有很多时间准备，下班收拾一下就已经很晚了。<br>因此结果也都好惨，说到底还是自己的基础不扎实，不过也算是攒了一点点经验，总比一次都没面还以为自己懂很多要好的多。</p>\n<p>之前搭的博客因为不小心错删本地文件一直耽搁着，最近因为面试受到了不少刺激，于是决定开始继续写博客<br>最近一段时间的总结就是：学习一定要有输出，这样记忆才会深刻一些。</p>\n<h3 id=\"希望从此刻慢慢缩小差距\"><a href=\"#希望从此刻慢慢缩小差距\" class=\"headerlink\" title=\"希望从此刻慢慢缩小差距\"></a>希望从此刻慢慢缩小差距</h3><h2 id=\"这几天经常被问到的问题，下面就按相关问题展开学习：\"><a href=\"#这几天经常被问到的问题，下面就按相关问题展开学习：\" class=\"headerlink\" title=\"这几天经常被问到的问题，下面就按相关问题展开学习：\"></a>这几天经常被问到的问题，下面就按相关问题展开学习：</h2><p>spring中的IOC和AOP，是为了解决什么样的问题<br>为什么要使用spring<br>关于字符串，如果有很多很多字符串拼接，不能总用+,效率太低了，那要怎样处理<br>数据库优化问题<br>一些排序问题<br>常用的设计模式，哪些场景会用到<br>多线程，concurrent包中有哪些常用类，以及使用<br>线程池问题<br>集合的问题<br>Java的反射机制，什么情况会用到<br>关于关键字final static volatile<br>内存模型<br>gc如何回收，什么情况会回收，什么样算是不再被使用了<br>栈是如何实现的<br>算法<br>关于网站中的爬虫，如何反爬虫，对于反爬虫措施如何避免<br>关于Socket<br>关于网络原理<br>mongodb和MySQL的区别</p>\n<p>前端http通信的过程</p>\n","categories":["essay"],"tags":["essay"]},{"title":"about var","url":"http://yoursite.com/2017/04/25/about var/","content":"<h2 id=\"最近遇到了一个关于var变量很简单的问题，废话不多说，直接看问题：\"><a href=\"#最近遇到了一个关于var变量很简单的问题，废话不多说，直接看问题：\" class=\"headerlink\" title=\"最近遇到了一个关于var变量很简单的问题，废话不多说，直接看问题：\"></a>最近遇到了一个关于var变量很简单的问题，废话不多说，直接看问题：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(global);</div><div class=\"line\">\t<span class=\"keyword\">var</span> global = <span class=\"string\">'world'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(global);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"两次打印，第一次undefined，第二次是world，笔者一直以为两次应该是hello和world，很是困扰。\"><a href=\"#两次打印，第一次undefined，第二次是world，笔者一直以为两次应该是hello和world，很是困扰。\" class=\"headerlink\" title=\"两次打印，第一次undefined，第二次是world，笔者一直以为两次应该是hello和world，很是困扰。\"></a>两次打印，第一次undefined，第二次是world，笔者一直以为两次应该是hello和world，很是困扰。</h2><h2 id=\"如果把后面两行去掉：\"><a href=\"#如果把后面两行去掉：\" class=\"headerlink\" title=\"如果把后面两行去掉：\"></a>如果把后面两行去掉：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(global);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"这样子打印出来就是hello，那肯定是和后定义的变量有关系了。\"><a href=\"#这样子打印出来就是hello，那肯定是和后定义的变量有关系了。\" class=\"headerlink\" title=\"这样子打印出来就是hello，那肯定是和后定义的变量有关系了。\"></a>这样子打印出来就是hello，那肯定是和后定义的变量有关系了。</h2><h2 id=\"果然，在网上查了一下，第二个var变量作用于整个function，个人理解也就是相当于：\"><a href=\"#果然，在网上查了一下，第二个var变量作用于整个function，个人理解也就是相当于：\" class=\"headerlink\" title=\"果然，在网上查了一下，第二个var变量作用于整个function，个人理解也就是相当于：\"></a>果然，在网上查了一下，第二个var变量作用于整个function，个人理解也就是相当于：</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> global = <span class=\"string\">'hello'</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> global;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(global);</div><div class=\"line\">\tglobal = <span class=\"string\">'world'</span>;</div><div class=\"line\">\t<span class=\"built_in\">console</span>.log(global);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"那要是函数内有相同变量就不可以访问全局变量了吗，答案当然是否定的\"><a href=\"#那要是函数内有相同变量就不可以访问全局变量了吗，答案当然是否定的\" class=\"headerlink\" title=\"那要是函数内有相同变量就不可以访问全局变量了吗，答案当然是否定的\"></a>那要是函数内有相同变量就不可以访问全局变量了吗，答案当然是否定的</h2><h2 id=\"在函数内可以通过window-global调用全局变量，\"><a href=\"#在函数内可以通过window-global调用全局变量，\" class=\"headerlink\" title=\"在函数内可以通过window.global调用全局变量，\"></a>在函数内可以通过window.global调用全局变量，</h2><h2 id=\"另外function内的this也是指向window实例，也可以吧引用写成this-global\"><a href=\"#另外function内的this也是指向window实例，也可以吧引用写成this-global\" class=\"headerlink\" title=\"另外function内的this也是指向window实例，也可以吧引用写成this.global\"></a>另外function内的this也是指向window实例，也可以吧引用写成this.global</h2><h2 id=\"当然最好还是尽量避免同名变量的出现，减少出错的概率。\"><a href=\"#当然最好还是尽量避免同名变量的出现，减少出错的概率。\" class=\"headerlink\" title=\"当然最好还是尽量避免同名变量的出现，减少出错的概率。\"></a>当然最好还是尽量避免同名变量的出现，减少出错的概率。</h2>","categories":["JS"],"tags":["Javascript"]},{"title":"about","url":"http://yoursite.com/about/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"link","url":"http://yoursite.com/link/index.html","content":"","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]},{"title":"project","url":"http://yoursite.com/project/index.html","content":"","categories":[],"tags":[]}]